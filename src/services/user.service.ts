import apiClient from './apiClient';
import { TUser, TSession, TReport, TUserSubscription } from '../types';

// --- Request Body Type Definitions ---

// Type for creating a new user (omits fields generated by DB/server)
type TCreateUserData = Pick<TUser, 'name' | 'email' | 'dateOfBirth'> & {
  password: string; // Password is required on creation
  campus?: string; // Optional campus FOR NOW
};

// Type for basic user updates (name, email)
type TUpdateUserData = Partial<Pick<TUser, 'name' | 'email'>>;

// Type for updating password
type TUpdatePasswordData = {
  oldPassword: string;
  newPassword: string;
};

// Type for blocking a user
type TBlockUserData = {
  blockedUserId: string;
};

// Type for adding/removing a friend
type TFriendData = {
  friendId: string;
};

// Type for updating subscription
type TUpdateSubscriptionData = {
  tier: TUserSubscription['tier']; // 'basic' | 'pro'
};

// Type for reporting a user
type TReportUserData = {
  reportedBy: string; // The ID of the user submitting the report
  reason: string;
};

// --- API Service Object ---

export const userService = {
  /**
   * Fetches all users.
   * GET /api/users
   */
  getAllUsers: () => {
    return apiClient.get<TUser[]>('/users');
  },

  /**
   * Creates a new user.
   * POST /api/users
   */
  createUser: (userData: TCreateUserData) => {
    // Backend returns the created user object
    return apiClient.post<{ message: string; user: TUser }>('/users', userData);
  },

  /**
   * Adds a session to a user's joinedSessions list.
   * POST /api/users/:userId/sessions
   */
  addSessionToUser: (userId: string, sessionId: string) => {
    return apiClient.post<{ message: string; joinedSessions: string[] }>(
      `/users/${userId}/sessions`,
      { sessionId }
    );
  },

  /**
   * Removes a session from a user's joinedSessions list.
   * DELETE /api/users/:userId/sessions/:sessionId
   */
  removeSessionFromUser: (userId: string, sessionId: string) => {
    return apiClient.delete<{ message: string }>(
      `/users/${userId}/sessions/${sessionId}`
    );
  },

  /**
   * Fetches a single user by their ID.
   * GET /api/users/:id
   */
  getUserById: (id: string) => {
    return apiClient.get<TUser>(`/users/${id}`);
  },

  /**
   * Updates a user's basic info (name, email).
   * PUT /api/users/:id
   */
  updateUser: (id: string, updates: TUpdateUserData) => {
    return apiClient.put<{ message: string; user: TUser }>(`/users/${id}`, updates);
  },

  /**
   * Deletes a user by ID.
   * DELETE /api/users/:id
   */
  deleteUser: (id: string) => {
    return apiClient.delete<{ message: string }>(`/users/${id}`);
  },

  /**
   * Adds a friend relationship between two users.
   * POST /api/users/:id/friends
   */
  addFriend: (userId: string, friendId: string) => {
    return apiClient.post<{ message: string; user: TUser }>(
      `/users/${userId}/friends`,
      { friendId }
    );
  },

  /**
   * Updates a user's password after verifying the old one.
   * PUT /api/users/:id/password
   */
  updatePassword: (userId: string, passwordData: TUpdatePasswordData) => {
    return apiClient.put<{ message: string }>(`/users/${userId}/password`, passwordData);
  },

  /**
   * Adds a user to the current user's block list.
   * PUT /api/users/:id/block
   */
  blockUser: (userId: string, blockedUserId: string) => {
    return apiClient.put<{ message: string; user: TUser }>(
      `/users/${userId}/block`,
      { blockedUserId } // Note: Backend controller uses this key
    );
  },

  /**
   * Fetches the list of users blocked by the specified user.
   * GET /api/users/:id/blocked
   */
  getBlockedUsers: (userId: string) => {
    // Assuming backend populates blockedUsers with name/email
    return apiClient.get<{ blockedUsers: Pick<TUser, '_id' | 'name' | 'email'>[] }>(
      `/users/${userId}/blocked`
    );
  },

  /**
   * Removes a friend relationship between two users.
   * PUT /api/users/:id/unfriend
   */
  removeFriend: (userId: string, friendId: string) => {
    return apiClient.put<{ message: string; user: TUser }>(
      `/users/${userId}/unfriend`,
      { friendId }
    );
  },

  /**
   * Fetches the list of friends for the specified user.
   * GET /api/users/:id/friends
   */
  getFriends: (userId: string) => {
    // Assuming backend populates friends with name/email
    return apiClient.get<{ friends: Pick<TUser, '_id' | 'name' | 'email'>[] }>(
      `/users/${userId}/friends`
    );
  },

  /**
   * Fetches the subscription tier for the specified user.
   * GET /api/users/:id/subscription
   */
  getSubscription: (userId: string) => {
    return apiClient.get<{ subscription: TUserSubscription }>(
      `/users/${userId}/subscription`
    );
  },

  /**
   * Updates the subscription tier for the specified user.
   * PUT /api/users/:id/subscription
   */
  updateSubscription: (userId: string, tierData: TUpdateSubscriptionData) => {
    return apiClient.put<{ message: string; subscription: TUserSubscription }>(
      `/users/${userId}/subscription`,
      tierData
    );
  },

  /**
   * Fetches hosted, joined, and invited sessions for a user.
   * GET /api/users/:id/activity
   */
  getUserActivity: (userId: string) => {
    // Define a more specific type for the activity response
    type TUserActivityResponse = {
      user: Pick<TUser, '_id' | 'name' | 'email'>;
      hostedSessions: TSession[]; // Assuming backend populates these
      joinedSessions: TSession[]; // Assuming backend populates these
      invitedSessions: TSession[]; // Assuming backend populates these
    };
    return apiClient.get<TUserActivityResponse>(`/users/${userId}/activity`);
  },

  /**
   * Submits a report against a user.
   * POST /api/users/:id/report
   */
  reportUser: (reportedUserId: string, reportData: TReportUserData) => {
    return apiClient.post<{ message: string }>(
      `/users/${reportedUserId}/report`,
      reportData
    );
  },

  /**
   * Searches for users by name (case-insensitive).
   * GET /api/users/search?name=...
   */
  searchUser: (nameQuery: string) => {
    return apiClient.get<TUser[]>(`/users/search`, {
      params: { name: nameQuery },
    });
  },
};
